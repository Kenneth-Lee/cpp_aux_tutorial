.. Kenneth Lee 版权所有 2022

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2022-11-07
:Status: Draft

学习一点汇编的知识
******************

综述
====

讨论了封装，我们开始学习一点汇编有关的知识吧。

我们说了，计算机只认识机器码，机器码就是数字，很难记，汇编是用文字代表这些数字，
这是为了人的方便，但它还是比C/C++这些语言更接近机器，基本上，我们可以认为，汇编
差不多就是机器语言，因为它们可以一一对应过去的。理解机器能“听懂”什么话，有助于
我们理解我们的高级语言为什么是那个样子的。

我们写的程序，编译出来二进制，可以用编译器的反编译工具恢复成汇编语言，这样我们就
能看到它作为汇编的样子。

我们前面讲\ `Makefile <5>`_ \ 的时候，讲过两种编译的方法，分别是这样的：::

  g++ test.cpp -o test

  g++ -c test.cpp -o test.o
  g++ test.o -o test

前面这个编译成可执行程序（如果在Windows下叫test.exe），后面这个编译成一个中间文
件，等有很多个.o的时候，再链接成可以执行的文件。

test.o和test.exe的区别有两个：

1. test.o只有你的test.cpp要求的内容，test.exe包含所有运行需要的内容，包括那些cout的实现
2. test.o的所有符号的位置是没有确定的，test.exe的是确定的。

我们编译下面这个程序看看：

.. code:: cpp

   int a = 10;
   int main(void) {
        return a;
   }

编译成.o：::

  g++ test.cpp -o test.o
  objdump -D test.o > test.S

第二条命令把obj文件（.o文件）dump成汇编（-D的作用），结果是这样的：::

  Disassembly of section .text:
  
  0000000000000000 <main>:
     0:	f3 0f 1e fa          	endbr64 
     4:	55                   	push   %rbp
     5:	48 89 e5             	mov    %rsp,%rbp
     8:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # e <main+0xe>
     e:	5d                   	pop    %rbp
     f:	c3                   	ret    
  
  Disassembly of section .data:
  
  0000000000000000 <a>:
     0:	0a 00                	or     (%rax),%al

这个文件把程序分成一段段（section），我们看到每段的地址都是0，这是因为还没有链
接，没有确定这些代码都放在哪里。所以，都没有内容。

这里有两个段：

1. .text，里面只有一个函数main，下面是它的代码，地址在0, 4, 5，这些内存位置上。
   我们一会儿再去解释每条指令的具体含义，我先提醒其中一个特征：这里main访问了a，
   但a还没有确定位置，所以那条mov 0x0(%rip), %eax里面本来是要找a的，但现在只是
   放了一个0。

2. .data段，这里就放了一个0a00，objdump也对这个东西反汇编了（or (%rax), %al），
   但其实这个不是语句，这只是个数字10（原文是十六进制表达），但objdump也分不出
   这个，所以也给你反汇编了。

我们再看看.exe的反汇编结果：::

  0000000000001129 <main>:
      1129:	f3 0f 1e fa          	endbr64 
      112d:	55                   	push   %rbp
      112e:	48 89 e5             	mov    %rsp,%rbp
      1131:	8b 05 d9 2e 00 00    	mov    0x2ed9(%rip),%eax        # 4010 <a>
      1137:	5d                   	pop    %rbp
      1138:	c3                   	ret    
  Disassembly of section .data:
  
  0000000000004000 <__data_start>:
	  ...
  
  0000000000004008 <__dso_handle>:
      4008:	08 40 00             	or     %al,0x0(%rax)
      400b:	00 00                	add    %al,(%rax)
      400d:	00 00                	add    %al,(%rax)
	  ...
  
  0000000000004010 <a>:
      4010:	0a 00                	or     (%rax),%al

如果你直接去看反汇编的结果，那里的内容比我这里多得多，因为g++把其他内容也链接进
来了，我只是继续给你看这个main和a在什么地方。

可以看到，现在main有了确定的位置，main在1129的位置上，而a在4010的位置上，main里面访问
a的位置也变成了mov 0x2ed9(%rip), %eax，它专门说了，这个地址就是4010的位置。

你的程序大致就是这么构成的，我们这里也不需要学习具体怎么写这些汇编，但大概知道
它的原理，有助于我们想明白编译器都在翻译成什么。我们这里就相当于你靠翻译来把你
说的中文翻译成英文，但你还是需要了解一些基本的英文文化，知道说英语的人都关心些
什么问题，这样你对翻译能翻译写什么有点了解，就更容易给翻译说清楚问题了。

x86_64的CPU抽象
===============

我们平时用的个人电脑（PC）用的CPU叫x86，历史我们就不说了，它有32位和64位两种版
本，这个背后的历史我们也不说了，反正32位和64位基本上指一条指令能操作的数据最大
有多大，32位表示CPU一次能操作32位的数，64位表示CPU一次能操作64位的数。我们马上
就会看到这个数字怎么其作用的。

所以，现在你拿到的PC基本就是x86_64版本的，做这个东西主要有两家公司，Intel和AMD，
两者作出来的硬件的汇编不是完全一样的，但只要你不用很高级的功能，你认为它们是一
样的就可以了。

在C++的角度，基本上我们说的每个存储都是指内存，就算它临时不是内存，需要的时候也
可以变成内存来讨论。但对于机器来说，不是这样的。在硬件上，CPU和内存其实离得很远。
这样说吧，CPU做一个加法，不算头尾的准备时间，通常只是时钟跳一次，但如果要从内存
里面读一个数据进来，时钟得跳100次以上。所以编译器没事通常是轻易不去访问内存的。
所以CPU里面有一个概念，叫寄存器，如果你只是要反复计算，不需要内存，就都在寄存器
里面算。

但计算机用内存还是有原因的，CPU里面的计算机很少，x86_64一般用来计算的，只有16个。
叫r0-r15。由于历史原因，前面八个有特别的名字：

.. list-table::

   * - 编号
     - 名字
     - 备注
   * - r0
     - rax
     - 函数第一个参数或者函数返回值
   * - r1
     - rbx
     -
   * - r2
     - rcx
     -
   * - r3
     - rdx
     - 
   * - r4
     - rsi
     -
   * - r5
     - rdi
     -
   * - r6
     - rbp
     - 当前函数堆栈首地址
   * - r7
     - rsp
     - 栈顶指针

剩下的就叫r8-r15了。她们的长度都是64位。现在你知道那个x86_64的64是什么意思了。
通常我们C++里面的int的长度，就是这个字长的长度。但这个为了兼容，有些平台把int定
义成32位的，比较乱，如果你实在需要知道长度，还是要用sizeof()判断才能做准。如果
你一定要64位的，就用int64_t就比较保险了。

有些寄存器是隐含的，从指令上看不见，比如RPC，表示当前要执行的指令，CPU根据RPC的
值决定从哪里读指令去执行，执行完后会更新到下一条指令，这个寄存器一般不参与计算。

那如果你要算一个short或者一个char怎么办呢？——你可以换个名字去访问这个寄存器，比如
rax，你换成eax，它就是32位的，ax就是16位的，al就是8位的。硬件上这个东西还是64bit，
但用的时候只用其中一部分。

如果要128位怎么办呢？编译器就要给你算两次。比如要加两个128位的整数，编译器就要
分两次加，先用adc加低64位，如果有进位就会放到另一个叫rflag的寄存器中，在用add加
高位和rflag的进位标记，变成一个完整的128位加法。

寄存器这个东西，随着CPU的功能增加，也会增加，比如机器学习经常那个要用向量计算，
为了配合这种计算，现代的x86中还支持SIMD（但单指令多数据）指令，这些指令用一组称
为xmm0-xmm15的寄存器，这些寄存器256位，你可以把一组向量放到每个寄存器中，一次对
整个向量做加减乘除。

浮点数也是32位或者64位的，按理说其实浮点数都可以放在r0-r15中，但还是因为历史原因。
x86的浮点数是用另一组寄存器来表示的。那个原理是一样的，我们这里不深入探讨。

x86_64 CPU的原理就不外这样了：CPU里面有寄存器，CPU根据RPC寄存器的内容读指令，然
后执行读写内存或者进行计算，完成后更新RPC，读下一条指令，重复上面过程，CPU就会
一直执行下去。

指令介绍
========

这里我们看一批指令，看看汇编这个语言的“文化”。

::

        mov eax, 100
        mov rax, rbx
        mov byte [var1], bl

这是移动指令，大部分汇编的语言习惯和memcpy类似，都是目标放前面，源放后面。前两
个指令一个把100写入eax，一个把rbx放到rax中。第三个是个内存访问指令，把bl写入
var1指向的内存中。var1是内存相对当前位置的偏移。

地址可以这样获得：::

        lea rax, [var1]

todo
