.. Kenneth Lee 版权所有 2022

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2022-11-07
:Status: Draft

学习一点汇编的知识
******************

讨论了封装，我们开始学习一点汇编有关的知识吧。

我们说了，计算机只认识机器码，机器码就是数字，很难机，汇编是用文字代表这些数字，
这是为了人的方便，但它还是比C/C++这些语言更接近机器，基本上，我们可以认为，汇编
差不多就是机器语言，因为它们可以一一对应过去的。理解机器能“听懂”什么话，有助于
我们理解我们的高级语言为什么是那个样子的。

我们写的程序，编译出来二进制，可以用编译器的反编译工具恢复成汇编语言，这样我们就
能看到它作为汇编的样子。

我们前面讲\ `Makefile <5>`_ \ 的时候，讲过两种编译的方法，分别是这样的：::

  g++ test.cpp -o test

  g++ -c test.cpp -o test.o
  g++ test.o -o test

前面这个编译成可执行程序（如果在Windows下叫test.exe），后面这个编译成一个中间文
件，等有很多个.o的时候，再链接成可以执行的文件。

test.o和test.exe的区别有两个：

1. test.o只有你的test.cpp要求的内容，test.exe包含所有运行需要的内容，包括那些cout的实现
2. test.o的所有符号的位置是没有确定的，test.exe的是确定的。

我们编译下面这个程序看看：

.. code:: cpp

   int a = 10;
   int main(void) {
        return a;
   }

编译成.o：::

  g++ test.cpp -o test.o
  objdump -D test.o > test.S

第二条命令把obj文件（.o文件）dump成汇编（-D的作用），结果是这样的：::

  Disassembly of section .text:
  
  0000000000000000 <main>:
     0:	f3 0f 1e fa          	endbr64 
     4:	55                   	push   %rbp
     5:	48 89 e5             	mov    %rsp,%rbp
     8:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # e <main+0xe>
     e:	5d                   	pop    %rbp
     f:	c3                   	ret    
  
  Disassembly of section .data:
  
  0000000000000000 <a>:
     0:	0a 00                	or     (%rax),%al

这个文件把程序分成一段段（section），我们看到每段的地址都是0，这是因为还没有链
接，没有确定这些代码都放在哪里。所以，都没有内容。

这里有两个段：

1. .text，里面只有一个函数main，下面是它的代码，地址在0, 4, 5，这些内存位置上。
   我们一会儿再去解释每条指令的具体含义，我先提醒其中一个特征：这里main访问了a，
   但a还没有确定位置，所以那条mov 0x0(%rip), %eax里面本来是要找a的，但现在只是
   放了一个0。

2. .data段，这里就放了一个0a00，objdump也对这个东西反汇编了（or (%rax), %al），
   但其实这个不是语句，这只是个数字10（原文是十六进制表达），但objdump也分不出
   这个，所以也给你反汇编了。

我们再看看.exe的反汇编结果：::

  0000000000001129 <main>:
      1129:	f3 0f 1e fa          	endbr64 
      112d:	55                   	push   %rbp
      112e:	48 89 e5             	mov    %rsp,%rbp
      1131:	8b 05 d9 2e 00 00    	mov    0x2ed9(%rip),%eax        # 4010 <a>
      1137:	5d                   	pop    %rbp
      1138:	c3                   	ret    
  Disassembly of section .data:
  
  0000000000004000 <__data_start>:
	  ...
  
  0000000000004008 <__dso_handle>:
      4008:	08 40 00             	or     %al,0x0(%rax)
      400b:	00 00                	add    %al,(%rax)
      400d:	00 00                	add    %al,(%rax)
	  ...
  
  0000000000004010 <a>:
      4010:	0a 00                	or     (%rax),%al

如果你直接去看反汇编的结果，那里的内容比我这里多得多，因为g++把其他内容也链接进
来了，我只是继续给你看这个main和a在什么地方。

可以看到，现在main有了确定的位置，main在1129的位置上，而a在4010的位置上，main里面访问
a的位置也变成了mov 0x2ed9(%rip), %eax，它专门说了，这个地址就是4010的位置。

todo
