.. Kenneth Lee 版权所有 2024

:Authors: Kenneth Lee
:Version: 0.1
:Date: 2024-01-29
:Status: Draft

理解调度器
**********

这一章，我们为做操作系统做准备，了解一下，到底什么是调度器。

我们已经知道，我们的计算机的计算中心是CPU，我们也看了汇编的样子了，知道CPU就是
一条指令一条指令去执行要求的功能。

现在我们需要考虑一下：我们平时用操作系统，开了很多个应用程序，但我们只有一个
CPU（现代的计算机会有更多，但也没有你开的应用多，那么，这些应用怎么分享这个或
者这些CPU呢？）

在最早的时候，计算机主要用来做科学计算，你写好了算法，跑去计算机中心，计算机管
理员给你排个队，等前面的人算完了，就放你的程序，到时告诉你结果就行了。

这叫批处理系统。负责调用完一个程序再调用下一个程序的方法，就叫这种批处理系统的
的“调度器”。大抵这个调度器就是跑完一个程序，然后去查一个列表，看看谁的优先级高，
高的那一个先跑。

我为这个章节写了一个示例，叫sched_tutor，工程在这里：
`sche_tutor <https://gitee.com/Kenneth-Lee-2012/sche_tutor>`_\ 。
其中的batch_sched.c就是一个批处理调度器的例子。我这里把所有的job都放在一个程序
中了，换成每个人写一个程序，其实也不过是多了把代码加载到内存不同位置的过程。原
理是一样的。

批处理调度在计算机很贵，各个研究机构为了一个计算还要专门跑到计算机中心去一趟的
时代可以，在现在这个时代肯定是不行的。就算到了后来，每个计算工程师分配一个“终
端”，大家都可以操作计算机的时代，它也是不行的，因为至少CPU还要时时刻刻来看看每
个终端有没有新的任务拿进来要求执行。

这种情况我们需要更灵活的调度器。我写第二个调度器给你看。就是sched_tutor中的
cothread_sched.c。我们通过这个例子来看看，多个任务是怎么分享同一个CPU的。

在这个例子中，我们和前面一样，还是支持三个job，也是都在做循环。但在循环的中间，
我们加入了几个yield函数，相当于调用了一下操作系统，让操作系统拥有一个“调度”的
机会，然后CPU就可以在循环的中间，从一个job跳到另一个job去执行。这样，这几个job
就可以“分时”使用这个CPU了。每次这个任务执行到yield的时候，操作系统就可以根据一
定的策略，决定选择哪个job运行，这也是一个调度。比如它可以按优先级调度，哪个job
的优先级高，就先调度它，它也可以按时间，谁运行的时间最少，就先运行谁。

这种调度叫做“协助式调度”，早期的Windows（比如Windows1.0），就是这样调度了，每
个job都要主动让出CPU，让操作系统调度下一个job进来运行。后来技术发展了以后，可
以不用job自己去调用yield了。而是通过时钟中断来解决这个问题。我们说过，CPU是按
着指令的序列一条条指令执行下去的。时钟中断是每隔一段时间（比如50ms），就产生一
个中断，相当于在指令序列走到一段时间后，突然调用一个指定的函数（成为中断向量），
这样，发生中断就相当于随机在某个job执行到某条指令以后，调用了一个Yield函数，这
样操作系统就可以进行调度了。其实本质上还是做了一个yield。

我们重点看看这个Yield是怎么做的。

todo.
